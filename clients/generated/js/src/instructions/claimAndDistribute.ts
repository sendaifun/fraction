/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  addDecoderSizePrefix,
  addEncoderSizePrefix,
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getAddressEncoder,
  getBytesDecoder,
  getBytesEncoder,
  getProgramDerivedAddress,
  getStructDecoder,
  getStructEncoder,
  getU32Decoder,
  getU32Encoder,
  getUtf8Decoder,
  getUtf8Encoder,
  transformEncoder,
  type AccountMeta,
  type AccountSignerMeta,
  type Address,
  type Codec,
  type Decoder,
  type Encoder,
  type Instruction,
  type InstructionWithAccounts,
  type InstructionWithData,
  type ReadonlyAccount,
  type ReadonlySignerAccount,
  type ReadonlyUint8Array,
  type TransactionSigner,
  type WritableAccount,
} from '@solana/kit';
import { SPLITS_PROGRAM_ADDRESS } from '../programs';
import {
  expectAddress,
  expectSome,
  getAccountMetaFactory,
  type ResolvedAccount,
} from '../shared';

export const CLAIM_AND_DISTRIBUTE_DISCRIMINATOR = new Uint8Array([
  111, 147, 210, 144, 253, 16, 187, 238,
]);

export function getClaimAndDistributeDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    CLAIM_AND_DISTRIBUTE_DISCRIMINATOR
  );
}

export type ClaimAndDistributeInstruction<
  TProgram extends string = typeof SPLITS_PROGRAM_ADDRESS,
  TAccountBot extends string | AccountMeta<string> = string,
  TAccountAuthority extends string | AccountMeta<string> = string,
  TAccountSplitterConfig extends string | AccountMeta<string> = string,
  TAccountTreasury extends string | AccountMeta<string> = string,
  TAccountTreasuryMint extends string | AccountMeta<string> = string,
  TAccountBotTokenAccount extends string | AccountMeta<string> = string,
  TAccountParticipantBalance0 extends string | AccountMeta<string> = string,
  TAccountParticipantBalance1 extends string | AccountMeta<string> = string,
  TAccountParticipantBalance2 extends string | AccountMeta<string> = string,
  TAccountParticipantBalance3 extends string | AccountMeta<string> = string,
  TAccountParticipantBalance4 extends string | AccountMeta<string> = string,
  TAccountBotBalance extends string | AccountMeta<string> = string,
  TAccountTokenProgram extends string | AccountMeta<string> = string,
  TRemainingAccounts extends readonly AccountMeta<string>[] = [],
> = Instruction<TProgram> &
  InstructionWithData<ReadonlyUint8Array> &
  InstructionWithAccounts<
    [
      TAccountBot extends string
        ? ReadonlySignerAccount<TAccountBot> & AccountSignerMeta<TAccountBot>
        : TAccountBot,
      TAccountAuthority extends string
        ? ReadonlyAccount<TAccountAuthority>
        : TAccountAuthority,
      TAccountSplitterConfig extends string
        ? WritableAccount<TAccountSplitterConfig>
        : TAccountSplitterConfig,
      TAccountTreasury extends string
        ? WritableAccount<TAccountTreasury>
        : TAccountTreasury,
      TAccountTreasuryMint extends string
        ? ReadonlyAccount<TAccountTreasuryMint>
        : TAccountTreasuryMint,
      TAccountBotTokenAccount extends string
        ? WritableAccount<TAccountBotTokenAccount>
        : TAccountBotTokenAccount,
      TAccountParticipantBalance0 extends string
        ? WritableAccount<TAccountParticipantBalance0>
        : TAccountParticipantBalance0,
      TAccountParticipantBalance1 extends string
        ? WritableAccount<TAccountParticipantBalance1>
        : TAccountParticipantBalance1,
      TAccountParticipantBalance2 extends string
        ? WritableAccount<TAccountParticipantBalance2>
        : TAccountParticipantBalance2,
      TAccountParticipantBalance3 extends string
        ? WritableAccount<TAccountParticipantBalance3>
        : TAccountParticipantBalance3,
      TAccountParticipantBalance4 extends string
        ? WritableAccount<TAccountParticipantBalance4>
        : TAccountParticipantBalance4,
      TAccountBotBalance extends string
        ? WritableAccount<TAccountBotBalance>
        : TAccountBotBalance,
      TAccountTokenProgram extends string
        ? ReadonlyAccount<TAccountTokenProgram>
        : TAccountTokenProgram,
      ...TRemainingAccounts,
    ]
  >;

export type ClaimAndDistributeInstructionData = {
  discriminator: ReadonlyUint8Array;
  name: string;
};

export type ClaimAndDistributeInstructionDataArgs = { name: string };

export function getClaimAndDistributeInstructionDataEncoder(): Encoder<ClaimAndDistributeInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
      ['name', addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder())],
    ]),
    (value) => ({ ...value, discriminator: CLAIM_AND_DISTRIBUTE_DISCRIMINATOR })
  );
}

export function getClaimAndDistributeInstructionDataDecoder(): Decoder<ClaimAndDistributeInstructionData> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
    ['name', addDecoderSizePrefix(getUtf8Decoder(), getU32Decoder())],
  ]);
}

export function getClaimAndDistributeInstructionDataCodec(): Codec<
  ClaimAndDistributeInstructionDataArgs,
  ClaimAndDistributeInstructionData
> {
  return combineCodec(
    getClaimAndDistributeInstructionDataEncoder(),
    getClaimAndDistributeInstructionDataDecoder()
  );
}

export type ClaimAndDistributeAsyncInput<
  TAccountBot extends string = string,
  TAccountAuthority extends string = string,
  TAccountSplitterConfig extends string = string,
  TAccountTreasury extends string = string,
  TAccountTreasuryMint extends string = string,
  TAccountBotTokenAccount extends string = string,
  TAccountParticipantBalance0 extends string = string,
  TAccountParticipantBalance1 extends string = string,
  TAccountParticipantBalance2 extends string = string,
  TAccountParticipantBalance3 extends string = string,
  TAccountParticipantBalance4 extends string = string,
  TAccountBotBalance extends string = string,
  TAccountTokenProgram extends string = string,
> = {
  bot: TransactionSigner<TAccountBot>;
  authority: Address<TAccountAuthority>;
  splitterConfig?: Address<TAccountSplitterConfig>;
  treasury?: Address<TAccountTreasury>;
  treasuryMint: Address<TAccountTreasuryMint>;
  botTokenAccount: Address<TAccountBotTokenAccount>;
  participantBalance0: Address<TAccountParticipantBalance0>;
  participantBalance1: Address<TAccountParticipantBalance1>;
  participantBalance2: Address<TAccountParticipantBalance2>;
  participantBalance3: Address<TAccountParticipantBalance3>;
  participantBalance4: Address<TAccountParticipantBalance4>;
  botBalance?: Address<TAccountBotBalance>;
  tokenProgram: Address<TAccountTokenProgram>;
  name: ClaimAndDistributeInstructionDataArgs['name'];
};

export async function getClaimAndDistributeInstructionAsync<
  TAccountBot extends string,
  TAccountAuthority extends string,
  TAccountSplitterConfig extends string,
  TAccountTreasury extends string,
  TAccountTreasuryMint extends string,
  TAccountBotTokenAccount extends string,
  TAccountParticipantBalance0 extends string,
  TAccountParticipantBalance1 extends string,
  TAccountParticipantBalance2 extends string,
  TAccountParticipantBalance3 extends string,
  TAccountParticipantBalance4 extends string,
  TAccountBotBalance extends string,
  TAccountTokenProgram extends string,
  TProgramAddress extends Address = typeof SPLITS_PROGRAM_ADDRESS,
>(
  input: ClaimAndDistributeAsyncInput<
    TAccountBot,
    TAccountAuthority,
    TAccountSplitterConfig,
    TAccountTreasury,
    TAccountTreasuryMint,
    TAccountBotTokenAccount,
    TAccountParticipantBalance0,
    TAccountParticipantBalance1,
    TAccountParticipantBalance2,
    TAccountParticipantBalance3,
    TAccountParticipantBalance4,
    TAccountBotBalance,
    TAccountTokenProgram
  >,
  config?: { programAddress?: TProgramAddress }
): Promise<
  ClaimAndDistributeInstruction<
    TProgramAddress,
    TAccountBot,
    TAccountAuthority,
    TAccountSplitterConfig,
    TAccountTreasury,
    TAccountTreasuryMint,
    TAccountBotTokenAccount,
    TAccountParticipantBalance0,
    TAccountParticipantBalance1,
    TAccountParticipantBalance2,
    TAccountParticipantBalance3,
    TAccountParticipantBalance4,
    TAccountBotBalance,
    TAccountTokenProgram
  >
> {
  // Program address.
  const programAddress = config?.programAddress ?? SPLITS_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    bot: { value: input.bot ?? null, isWritable: false },
    authority: { value: input.authority ?? null, isWritable: false },
    splitterConfig: { value: input.splitterConfig ?? null, isWritable: true },
    treasury: { value: input.treasury ?? null, isWritable: true },
    treasuryMint: { value: input.treasuryMint ?? null, isWritable: false },
    botTokenAccount: { value: input.botTokenAccount ?? null, isWritable: true },
    participantBalance0: {
      value: input.participantBalance0 ?? null,
      isWritable: true,
    },
    participantBalance1: {
      value: input.participantBalance1 ?? null,
      isWritable: true,
    },
    participantBalance2: {
      value: input.participantBalance2 ?? null,
      isWritable: true,
    },
    participantBalance3: {
      value: input.participantBalance3 ?? null,
      isWritable: true,
    },
    participantBalance4: {
      value: input.participantBalance4 ?? null,
      isWritable: true,
    },
    botBalance: { value: input.botBalance ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.splitterConfig.value) {
    accounts.splitterConfig.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(
          new Uint8Array([
            115, 112, 108, 105, 116, 116, 101, 114, 95, 99, 111, 110, 102, 105,
            103,
          ])
        ),
        getAddressEncoder().encode(expectAddress(accounts.authority.value)),
        addEncoderSizePrefix(getUtf8Encoder(), getU32Encoder()).encode(
          expectSome(args.name)
        ),
      ],
    });
  }
  if (!accounts.treasury.value) {
    accounts.treasury.value = await getProgramDerivedAddress({
      programAddress:
        'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL' as Address<'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL'>,
      seeds: [
        getAddressEncoder().encode(
          expectAddress(accounts.splitterConfig.value)
        ),
        getAddressEncoder().encode(expectAddress(accounts.tokenProgram.value)),
        getAddressEncoder().encode(expectAddress(accounts.treasuryMint.value)),
      ],
    });
  }
  if (!accounts.botBalance.value) {
    accounts.botBalance.value = await getProgramDerivedAddress({
      programAddress,
      seeds: [
        getBytesEncoder().encode(
          new Uint8Array([98, 111, 116, 95, 98, 97, 108, 97, 110, 99, 101])
        ),
        getAddressEncoder().encode(
          expectAddress(accounts.splitterConfig.value)
        ),
        getAddressEncoder().encode(expectAddress(accounts.bot.value)),
      ],
    });
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  const instruction = {
    accounts: [
      getAccountMeta(accounts.bot),
      getAccountMeta(accounts.authority),
      getAccountMeta(accounts.splitterConfig),
      getAccountMeta(accounts.treasury),
      getAccountMeta(accounts.treasuryMint),
      getAccountMeta(accounts.botTokenAccount),
      getAccountMeta(accounts.participantBalance0),
      getAccountMeta(accounts.participantBalance1),
      getAccountMeta(accounts.participantBalance2),
      getAccountMeta(accounts.participantBalance3),
      getAccountMeta(accounts.participantBalance4),
      getAccountMeta(accounts.botBalance),
      getAccountMeta(accounts.tokenProgram),
    ],
    programAddress,
    data: getClaimAndDistributeInstructionDataEncoder().encode(
      args as ClaimAndDistributeInstructionDataArgs
    ),
  } as ClaimAndDistributeInstruction<
    TProgramAddress,
    TAccountBot,
    TAccountAuthority,
    TAccountSplitterConfig,
    TAccountTreasury,
    TAccountTreasuryMint,
    TAccountBotTokenAccount,
    TAccountParticipantBalance0,
    TAccountParticipantBalance1,
    TAccountParticipantBalance2,
    TAccountParticipantBalance3,
    TAccountParticipantBalance4,
    TAccountBotBalance,
    TAccountTokenProgram
  >;

  return instruction;
}

export type ClaimAndDistributeInput<
  TAccountBot extends string = string,
  TAccountAuthority extends string = string,
  TAccountSplitterConfig extends string = string,
  TAccountTreasury extends string = string,
  TAccountTreasuryMint extends string = string,
  TAccountBotTokenAccount extends string = string,
  TAccountParticipantBalance0 extends string = string,
  TAccountParticipantBalance1 extends string = string,
  TAccountParticipantBalance2 extends string = string,
  TAccountParticipantBalance3 extends string = string,
  TAccountParticipantBalance4 extends string = string,
  TAccountBotBalance extends string = string,
  TAccountTokenProgram extends string = string,
> = {
  bot: TransactionSigner<TAccountBot>;
  authority: Address<TAccountAuthority>;
  splitterConfig: Address<TAccountSplitterConfig>;
  treasury: Address<TAccountTreasury>;
  treasuryMint: Address<TAccountTreasuryMint>;
  botTokenAccount: Address<TAccountBotTokenAccount>;
  participantBalance0: Address<TAccountParticipantBalance0>;
  participantBalance1: Address<TAccountParticipantBalance1>;
  participantBalance2: Address<TAccountParticipantBalance2>;
  participantBalance3: Address<TAccountParticipantBalance3>;
  participantBalance4: Address<TAccountParticipantBalance4>;
  botBalance: Address<TAccountBotBalance>;
  tokenProgram: Address<TAccountTokenProgram>;
  name: ClaimAndDistributeInstructionDataArgs['name'];
};

export function getClaimAndDistributeInstruction<
  TAccountBot extends string,
  TAccountAuthority extends string,
  TAccountSplitterConfig extends string,
  TAccountTreasury extends string,
  TAccountTreasuryMint extends string,
  TAccountBotTokenAccount extends string,
  TAccountParticipantBalance0 extends string,
  TAccountParticipantBalance1 extends string,
  TAccountParticipantBalance2 extends string,
  TAccountParticipantBalance3 extends string,
  TAccountParticipantBalance4 extends string,
  TAccountBotBalance extends string,
  TAccountTokenProgram extends string,
  TProgramAddress extends Address = typeof SPLITS_PROGRAM_ADDRESS,
>(
  input: ClaimAndDistributeInput<
    TAccountBot,
    TAccountAuthority,
    TAccountSplitterConfig,
    TAccountTreasury,
    TAccountTreasuryMint,
    TAccountBotTokenAccount,
    TAccountParticipantBalance0,
    TAccountParticipantBalance1,
    TAccountParticipantBalance2,
    TAccountParticipantBalance3,
    TAccountParticipantBalance4,
    TAccountBotBalance,
    TAccountTokenProgram
  >,
  config?: { programAddress?: TProgramAddress }
): ClaimAndDistributeInstruction<
  TProgramAddress,
  TAccountBot,
  TAccountAuthority,
  TAccountSplitterConfig,
  TAccountTreasury,
  TAccountTreasuryMint,
  TAccountBotTokenAccount,
  TAccountParticipantBalance0,
  TAccountParticipantBalance1,
  TAccountParticipantBalance2,
  TAccountParticipantBalance3,
  TAccountParticipantBalance4,
  TAccountBotBalance,
  TAccountTokenProgram
> {
  // Program address.
  const programAddress = config?.programAddress ?? SPLITS_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    bot: { value: input.bot ?? null, isWritable: false },
    authority: { value: input.authority ?? null, isWritable: false },
    splitterConfig: { value: input.splitterConfig ?? null, isWritable: true },
    treasury: { value: input.treasury ?? null, isWritable: true },
    treasuryMint: { value: input.treasuryMint ?? null, isWritable: false },
    botTokenAccount: { value: input.botTokenAccount ?? null, isWritable: true },
    participantBalance0: {
      value: input.participantBalance0 ?? null,
      isWritable: true,
    },
    participantBalance1: {
      value: input.participantBalance1 ?? null,
      isWritable: true,
    },
    participantBalance2: {
      value: input.participantBalance2 ?? null,
      isWritable: true,
    },
    participantBalance3: {
      value: input.participantBalance3 ?? null,
      isWritable: true,
    },
    participantBalance4: {
      value: input.participantBalance4 ?? null,
      isWritable: true,
    },
    botBalance: { value: input.botBalance ?? null, isWritable: true },
    tokenProgram: { value: input.tokenProgram ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  const instruction = {
    accounts: [
      getAccountMeta(accounts.bot),
      getAccountMeta(accounts.authority),
      getAccountMeta(accounts.splitterConfig),
      getAccountMeta(accounts.treasury),
      getAccountMeta(accounts.treasuryMint),
      getAccountMeta(accounts.botTokenAccount),
      getAccountMeta(accounts.participantBalance0),
      getAccountMeta(accounts.participantBalance1),
      getAccountMeta(accounts.participantBalance2),
      getAccountMeta(accounts.participantBalance3),
      getAccountMeta(accounts.participantBalance4),
      getAccountMeta(accounts.botBalance),
      getAccountMeta(accounts.tokenProgram),
    ],
    programAddress,
    data: getClaimAndDistributeInstructionDataEncoder().encode(
      args as ClaimAndDistributeInstructionDataArgs
    ),
  } as ClaimAndDistributeInstruction<
    TProgramAddress,
    TAccountBot,
    TAccountAuthority,
    TAccountSplitterConfig,
    TAccountTreasury,
    TAccountTreasuryMint,
    TAccountBotTokenAccount,
    TAccountParticipantBalance0,
    TAccountParticipantBalance1,
    TAccountParticipantBalance2,
    TAccountParticipantBalance3,
    TAccountParticipantBalance4,
    TAccountBotBalance,
    TAccountTokenProgram
  >;

  return instruction;
}

export type ParsedClaimAndDistributeInstruction<
  TProgram extends string = typeof SPLITS_PROGRAM_ADDRESS,
  TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    bot: TAccountMetas[0];
    authority: TAccountMetas[1];
    splitterConfig: TAccountMetas[2];
    treasury: TAccountMetas[3];
    treasuryMint: TAccountMetas[4];
    botTokenAccount: TAccountMetas[5];
    participantBalance0: TAccountMetas[6];
    participantBalance1: TAccountMetas[7];
    participantBalance2: TAccountMetas[8];
    participantBalance3: TAccountMetas[9];
    participantBalance4: TAccountMetas[10];
    botBalance: TAccountMetas[11];
    tokenProgram: TAccountMetas[12];
  };
  data: ClaimAndDistributeInstructionData;
};

export function parseClaimAndDistributeInstruction<
  TProgram extends string,
  TAccountMetas extends readonly AccountMeta[],
>(
  instruction: Instruction<TProgram> &
    InstructionWithAccounts<TAccountMetas> &
    InstructionWithData<ReadonlyUint8Array>
): ParsedClaimAndDistributeInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 13) {
    // TODO: Coded error.
    throw new Error('Not enough accounts');
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      bot: getNextAccount(),
      authority: getNextAccount(),
      splitterConfig: getNextAccount(),
      treasury: getNextAccount(),
      treasuryMint: getNextAccount(),
      botTokenAccount: getNextAccount(),
      participantBalance0: getNextAccount(),
      participantBalance1: getNextAccount(),
      participantBalance2: getNextAccount(),
      participantBalance3: getNextAccount(),
      participantBalance4: getNextAccount(),
      botBalance: getNextAccount(),
      tokenProgram: getNextAccount(),
    },
    data: getClaimAndDistributeInstructionDataDecoder().decode(
      instruction.data
    ),
  };
}
