/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  containsBytes,
  fixEncoderSize,
  getBytesEncoder,
  type Address,
  type ReadonlyUint8Array,
} from '@solana/kit';
import {
  type ParsedClaimAndDistributeInstruction,
  type ParsedInitializeSplitterInstruction,
  type ParsedUpdateSplitterInstruction,
  type ParsedWithdrawShareInstruction,
} from '../instructions';

export const SPLITS_PROGRAM_ADDRESS =
  'FM9hKTFN98M2uo7zw2huAbx7vJTQpfgFuxr9rVCTt8UY' as Address<'FM9hKTFN98M2uo7zw2huAbx7vJTQpfgFuxr9rVCTt8UY'>;

export enum SplitsAccount {
  ParticipantBalance,
  SplitterConfig,
}

export function identifySplitsAccount(
  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): SplitsAccount {
  const data = 'data' in account ? account.data : account;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([142, 219, 111, 115, 231, 38, 160, 173])
      ),
      0
    )
  ) {
    return SplitsAccount.ParticipantBalance;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([37, 70, 66, 89, 147, 213, 59, 153])
      ),
      0
    )
  ) {
    return SplitsAccount.SplitterConfig;
  }
  throw new Error(
    'The provided account could not be identified as a splits account.'
  );
}

export enum SplitsInstruction {
  ClaimAndDistribute,
  InitializeSplitter,
  UpdateSplitter,
  WithdrawShare,
}

export function identifySplitsInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): SplitsInstruction {
  const data = 'data' in instruction ? instruction.data : instruction;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([111, 147, 210, 144, 253, 16, 187, 238])
      ),
      0
    )
  ) {
    return SplitsInstruction.ClaimAndDistribute;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([81, 111, 81, 77, 41, 36, 149, 189])
      ),
      0
    )
  ) {
    return SplitsInstruction.InitializeSplitter;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([45, 2, 199, 7, 96, 249, 137, 255])
      ),
      0
    )
  ) {
    return SplitsInstruction.UpdateSplitter;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([169, 159, 52, 79, 59, 190, 159, 9])
      ),
      0
    )
  ) {
    return SplitsInstruction.WithdrawShare;
  }
  throw new Error(
    'The provided instruction could not be identified as a splits instruction.'
  );
}

export type ParsedSplitsInstruction<
  TProgram extends string = 'FM9hKTFN98M2uo7zw2huAbx7vJTQpfgFuxr9rVCTt8UY',
> =
  | ({
      instructionType: SplitsInstruction.ClaimAndDistribute;
    } & ParsedClaimAndDistributeInstruction<TProgram>)
  | ({
      instructionType: SplitsInstruction.InitializeSplitter;
    } & ParsedInitializeSplitterInstruction<TProgram>)
  | ({
      instructionType: SplitsInstruction.UpdateSplitter;
    } & ParsedUpdateSplitterInstruction<TProgram>)
  | ({
      instructionType: SplitsInstruction.WithdrawShare;
    } & ParsedWithdrawShareInstruction<TProgram>);
